{"componentChunkName":"component---src-templates-notebook-index-tsx","path":"/计算机与编程/React/SSR/","result":{"data":{"mdx":{"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"ssr\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"SSR\", mdx(\"a\", {\n    parentName: \"h1\",\n    \"href\": \"#ssr\",\n    \"aria-label\": \"ssr permalink\",\n    \"className\": \"autolink-header-icon after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"height\": \"20\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"20\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"How Razzle works (the secret sauce)\", mdx(\"br\", {\n    parentName: \"p\"\n  }), \"\\n\", \"TL;DR: 2 configs, 2 ports, 2 webpack instances, both watching and hot reloading the same filesystem, in parallel during development and a little\\xA0webpack.output.publicPath\\xA0magic.\", mdx(\"br\", {\n    parentName: \"p\"\n  }), \"\\n\", \"In development mode (razzle start), Razzle bundles both your client and server code using two different webpack instances running with Hot Module Replacement in parallel. While your server is bundled and run on whatever port you specify in\\xA0src/index.js\\xA0(3000\\xA0is the default), the client bundle (i.e. entry point at\\xA0src/client.js) is served via\\xA0webpack-dev-server\\xA0on a different port (3001\\xA0by default) with its\\xA0publicPath\\xA0explicitly set to\\xA0localhost:3001\\xA0(and not\\xA0/\\xA0like many other setups do). Then the server's html template just points to the absolute url of the client JS:\\xA0localhost:3001/static/js/client.js. Since both webpack instances watch the same files, whenever you make edits, they hot reload at\\xA0exactly\\xA0the same time. Best of all, because they use the same code, the same webpack loaders, and the same babel transformations, you never run into a React checksum mismatch error.\"), mdx(\"p\", null, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/jaredpalmer/razzle\",\n    \"target\": \"_blank\",\n    \"rel\": \"nofollow\"\n  }, \"https://github.com/jaredpalmer/razzle\")));\n}\n;\nMDXContent.isMDXComponent = true;","rawBody":"# SSR\n\nHow Razzle works (the secret sauce)\nTL;DR: 2 configs, 2 ports, 2 webpack instances, both watching and hot reloading the same filesystem, in parallel during development and a little webpack.output.publicPath magic.\nIn development mode (razzle start), Razzle bundles both your client and server code using two different webpack instances running with Hot Module Replacement in parallel. While your server is bundled and run on whatever port you specify in src/index.js (3000 is the default), the client bundle (i.e. entry point at src/client.js) is served via webpack-dev-server on a different port (3001 by default) with its publicPath explicitly set to localhost:3001 (and not / like many other setups do). Then the server's html template just points to the absolute url of the client JS: localhost:3001/static/js/client.js. Since both webpack instances watch the same files, whenever you make edits, they hot reload at exactly the same time. Best of all, because they use the same code, the same webpack loaders, and the same babel transformations, you never run into a React checksum mismatch error.\n\nhttps://github.com/jaredpalmer/razzle","tableOfContents":{"items":[{"url":"#ssr","title":"SSR"}]},"fields":{"filePath":"/计算机与编程/React/SSR.md"}}},"pageContext":{"title":"SSR","modifiedTime":"2021-05-31 20:07"}},"staticQueryHashes":["63159454"]}