{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./node_modules/lodash/isArguments.js","webpack:///./node_modules/lodash/_getRawTag.js","webpack:///./node_modules/lodash/_isFlattenable.js","webpack:///./node_modules/lodash/_arrayPush.js","webpack:///./node_modules/lodash/isObjectLike.js","webpack:///./node_modules/lodash/_baseIsArguments.js","webpack:///./node_modules/lodash/_objectToString.js","webpack:///./node_modules/lodash/_root.js","webpack:///./node_modules/lodash/_baseGetTag.js","webpack:///./node_modules/lodash/flatten.js","webpack:///./node_modules/lodash/_freeGlobal.js","webpack:///./node_modules/js-search/dist/esm/js-search.js","webpack:///./src/templates/client-search/search.worker.actions.js","webpack:///./src/templates/client-search/search.worker.js","webpack:///./src/utils/js-search.js","webpack:///./node_modules/lodash/_baseFlatten.js","webpack:///./node_modules/lodash/isArray.js","webpack:///./node_modules/lodash/_Symbol.js","webpack:///(webpack)/buildin/global.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","baseIsArguments","isObjectLike","objectProto","propertyIsEnumerable","isArguments","arguments","nativeObjectToString","toString","symToStringTag","undefined","isOwn","tag","unmasked","e","result","isArray","spreadableSymbol","isConcatSpreadable","array","values","index","length","offset","baseGetTag","freeGlobal","freeSelf","self","root","Function","getRawTag","objectToString","baseFlatten","global","PrefixIndexStrategy","expandToken","token","expandedTokens","string","charAt","push","LowerCaseSanitizer","sanitize","text","toLocaleLowerCase","trim","getNestedFieldValue","path","TfIdfSearchIndex","uidFieldName","this","_uidFieldName","_tokenToIdfCache","_tokenMap","_proto","indexDocument","uid","doc","tokenDatum","tokenMap","$numDocumentOccurrences","$totalNumOccurrences","$uidMap","uidMap","$document","$numTokenOccurrences","search","tokens","corpus","uidToDocumentMap","numTokens","tokenMetadata","j","numKeys","keys","documents","calculateTfIdf","_createCalculateTfIdf","sort","documentA","documentB","_createCalculateIdf","tokenToIdfCache","numDocumentsWithToken","Math","log","calculateIdf","document","score","inverseDocumentFrequency","Infinity","Array","REGEX","SimpleTokenizer","tokenize","split","filter","_defineProperties","target","props","descriptor","configurable","writable","Search","Error","_indexStrategy","_searchIndex","_sanitizer","_tokenizer","_documents","_searchableFields","Constructor","protoProps","staticProps","addDocument","addDocuments","concat","indexDocuments_","addIndex","field","query","_initialized","indexStrategy","sanitizer","searchIndex","tokenizer","di","numDocuments","sfi","numSearchableFields","fieldValue","searchableField","fieldTokens","fti","numFieldValues","fieldToken","eti","nummExpandedTokens","expandedToken","set","MESSAGE_TYPE","searchEngine","initSearchEngine","data","indexes","originTokenize","JsSearch","Boolean","map","v","segment","test","replace","forEach","addEventListener","type","payload","postMessage","console","arrayPush","isFlattenable","depth","predicate","isStrict","g","window"],"mappings":"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","file":"b8e128a6613726b7dace.worker.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"WZOE\");\n","var baseIsArguments = require('./_baseIsArguments'),\n    isObjectLike = require('./isObjectLike');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/** Built-in value references. */\nvar propertyIsEnumerable = objectProto.propertyIsEnumerable;\n\n/**\n * Checks if `value` is likely an `arguments` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n *  else `false`.\n * @example\n *\n * _.isArguments(function() { return arguments; }());\n * // => true\n *\n * _.isArguments([1, 2, 3]);\n * // => false\n */\nvar isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {\n  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&\n    !propertyIsEnumerable.call(value, 'callee');\n};\n\nmodule.exports = isArguments;\n","var Symbol = require('./_Symbol');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/** Built-in value references. */\nvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the raw `toStringTag`.\n */\nfunction getRawTag(value) {\n  var isOwn = hasOwnProperty.call(value, symToStringTag),\n      tag = value[symToStringTag];\n\n  try {\n    value[symToStringTag] = undefined;\n    var unmasked = true;\n  } catch (e) {}\n\n  var result = nativeObjectToString.call(value);\n  if (unmasked) {\n    if (isOwn) {\n      value[symToStringTag] = tag;\n    } else {\n      delete value[symToStringTag];\n    }\n  }\n  return result;\n}\n\nmodule.exports = getRawTag;\n","var Symbol = require('./_Symbol'),\n    isArguments = require('./isArguments'),\n    isArray = require('./isArray');\n\n/** Built-in value references. */\nvar spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined;\n\n/**\n * Checks if `value` is a flattenable `arguments` object or array.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.\n */\nfunction isFlattenable(value) {\n  return isArray(value) || isArguments(value) ||\n    !!(spreadableSymbol && value && value[spreadableSymbol]);\n}\n\nmodule.exports = isFlattenable;\n","/**\n * Appends the elements of `values` to `array`.\n *\n * @private\n * @param {Array} array The array to modify.\n * @param {Array} values The values to append.\n * @returns {Array} Returns `array`.\n */\nfunction arrayPush(array, values) {\n  var index = -1,\n      length = values.length,\n      offset = array.length;\n\n  while (++index < length) {\n    array[offset + index] = values[index];\n  }\n  return array;\n}\n\nmodule.exports = arrayPush;\n","/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return value != null && typeof value == 'object';\n}\n\nmodule.exports = isObjectLike;\n","var baseGetTag = require('./_baseGetTag'),\n    isObjectLike = require('./isObjectLike');\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]';\n\n/**\n * The base implementation of `_.isArguments`.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n */\nfunction baseIsArguments(value) {\n  return isObjectLike(value) && baseGetTag(value) == argsTag;\n}\n\nmodule.exports = baseIsArguments;\n","/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/**\n * Converts `value` to a string using `Object.prototype.toString`.\n *\n * @private\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n */\nfunction objectToString(value) {\n  return nativeObjectToString.call(value);\n}\n\nmodule.exports = objectToString;\n","var freeGlobal = require('./_freeGlobal');\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\nmodule.exports = root;\n","var Symbol = require('./_Symbol'),\n    getRawTag = require('./_getRawTag'),\n    objectToString = require('./_objectToString');\n\n/** `Object#toString` result references. */\nvar nullTag = '[object Null]',\n    undefinedTag = '[object Undefined]';\n\n/** Built-in value references. */\nvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * The base implementation of `getTag` without fallbacks for buggy environments.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction baseGetTag(value) {\n  if (value == null) {\n    return value === undefined ? undefinedTag : nullTag;\n  }\n  return (symToStringTag && symToStringTag in Object(value))\n    ? getRawTag(value)\n    : objectToString(value);\n}\n\nmodule.exports = baseGetTag;\n","var baseFlatten = require('./_baseFlatten');\n\n/**\n * Flattens `array` a single level deep.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Array\n * @param {Array} array The array to flatten.\n * @returns {Array} Returns the new flattened array.\n * @example\n *\n * _.flatten([1, [2, [3, [4]], 5]]);\n * // => [1, 2, [3, [4]], 5]\n */\nfunction flatten(array) {\n  var length = array == null ? 0 : array.length;\n  return length ? baseFlatten(array, 1) : [];\n}\n\nmodule.exports = flatten;\n","/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\nmodule.exports = freeGlobal;\n","/**\n * Indexes for all substring searches (e.g. the term \"cat\" is indexed as \"c\", \"ca\", \"cat\", \"a\", \"at\", and \"t\").\n */\nvar AllSubstringsIndexStrategy = /*#__PURE__*/function () {\n  function AllSubstringsIndexStrategy() {}\n\n  var _proto = AllSubstringsIndexStrategy.prototype;\n  /**\n   * @inheritDocs\n   */\n\n  _proto.expandToken = function expandToken(token) {\n    var expandedTokens = [];\n    var string;\n\n    for (var i = 0, length = token.length; i < length; ++i) {\n      string = '';\n\n      for (var j = i; j < length; ++j) {\n        string += token.charAt(j);\n        expandedTokens.push(string);\n      }\n    }\n\n    return expandedTokens;\n  };\n\n  return AllSubstringsIndexStrategy;\n}();\n/**\n * Indexes for exact word matches.\n */\n\n\nvar ExactWordIndexStrategy = /*#__PURE__*/function () {\n  function ExactWordIndexStrategy() {}\n\n  var _proto = ExactWordIndexStrategy.prototype;\n  /**\n   * @inheritDocs\n   */\n\n  _proto.expandToken = function expandToken(token) {\n    return token ? [token] : [];\n  };\n\n  return ExactWordIndexStrategy;\n}();\n/**\n * Indexes for prefix searches (e.g. the term \"cat\" is indexed as \"c\", \"ca\", and \"cat\" allowing prefix search lookups).\n */\n\n\nvar PrefixIndexStrategy = /*#__PURE__*/function () {\n  function PrefixIndexStrategy() {}\n\n  var _proto = PrefixIndexStrategy.prototype;\n  /**\n   * @inheritDocs\n   */\n\n  _proto.expandToken = function expandToken(token) {\n    var expandedTokens = [];\n    var string = '';\n\n    for (var i = 0, length = token.length; i < length; ++i) {\n      string += token.charAt(i);\n      expandedTokens.push(string);\n    }\n\n    return expandedTokens;\n  };\n\n  return PrefixIndexStrategy;\n}();\n/**\n * Enforces case-sensitive text matches.\n */\n\n\nvar CaseSensitiveSanitizer = /*#__PURE__*/function () {\n  function CaseSensitiveSanitizer() {}\n\n  var _proto = CaseSensitiveSanitizer.prototype;\n  /**\n   * @inheritDocs\n   */\n\n  _proto.sanitize = function sanitize(text) {\n    return text ? text.trim() : '';\n  };\n\n  return CaseSensitiveSanitizer;\n}();\n/**\n * Sanitizes text by converting to a locale-friendly lower-case version and triming leading and trailing whitespace.\n */\n\n\nvar LowerCaseSanitizer = /*#__PURE__*/function () {\n  function LowerCaseSanitizer() {}\n\n  var _proto = LowerCaseSanitizer.prototype;\n  /**\n   * @inheritDocs\n   */\n\n  _proto.sanitize = function sanitize(text) {\n    return text ? text.toLocaleLowerCase().trim() : '';\n  };\n\n  return LowerCaseSanitizer;\n}();\n/**\n * Find and return a nested object value.\n *\n * @param object to crawl\n * @param path Property path\n * @returns {any}\n */\n\n\nfunction getNestedFieldValue(object, path) {\n  path = path || [];\n  object = object || {};\n  var value = object; // walk down the property path\n\n  for (var i = 0; i < path.length; i++) {\n    value = value[path[i]];\n\n    if (value == null) {\n      return null;\n    }\n  }\n\n  return value;\n}\n/**\n * Search index capable of returning results matching a set of tokens and ranked according to TF-IDF.\n */\n\n\nvar TfIdfSearchIndex = /*#__PURE__*/function () {\n  function TfIdfSearchIndex(uidFieldName) {\n    this._uidFieldName = uidFieldName;\n    this._tokenToIdfCache = {};\n    this._tokenMap = {};\n  }\n  /**\n   * @inheritDocs\n   */\n\n\n  var _proto = TfIdfSearchIndex.prototype;\n\n  _proto.indexDocument = function indexDocument(token, uid, doc) {\n    this._tokenToIdfCache = {}; // New index invalidates previous IDF caches\n\n    var tokenMap = this._tokenMap;\n    var tokenDatum;\n\n    if (typeof tokenMap[token] !== 'object') {\n      tokenMap[token] = tokenDatum = {\n        $numDocumentOccurrences: 0,\n        $totalNumOccurrences: 1,\n        $uidMap: {}\n      };\n    } else {\n      tokenDatum = tokenMap[token];\n      tokenDatum.$totalNumOccurrences++;\n    }\n\n    var uidMap = tokenDatum.$uidMap;\n\n    if (typeof uidMap[uid] !== 'object') {\n      tokenDatum.$numDocumentOccurrences++;\n      uidMap[uid] = {\n        $document: doc,\n        $numTokenOccurrences: 1\n      };\n    } else {\n      uidMap[uid].$numTokenOccurrences++;\n    }\n  }\n  /**\n   * @inheritDocs\n   */\n  ;\n\n  _proto.search = function search(tokens, corpus) {\n    var uidToDocumentMap = {};\n\n    for (var i = 0, numTokens = tokens.length; i < numTokens; i++) {\n      var token = tokens[i];\n      var tokenMetadata = this._tokenMap[token]; // Short circuit if no matches were found for any given token.\n\n      if (!tokenMetadata) {\n        return [];\n      }\n\n      if (i === 0) {\n        var keys = Object.keys(tokenMetadata.$uidMap);\n\n        for (var j = 0, numKeys = keys.length; j < numKeys; j++) {\n          var uid = keys[j];\n          uidToDocumentMap[uid] = tokenMetadata.$uidMap[uid].$document;\n        }\n      } else {\n        var keys = Object.keys(uidToDocumentMap);\n\n        for (var j = 0, numKeys = keys.length; j < numKeys; j++) {\n          var uid = keys[j];\n\n          if (typeof tokenMetadata.$uidMap[uid] !== 'object') {\n            delete uidToDocumentMap[uid];\n          }\n        }\n      }\n    }\n\n    var documents = [];\n\n    for (var uid in uidToDocumentMap) {\n      documents.push(uidToDocumentMap[uid]);\n    }\n\n    var calculateTfIdf = this._createCalculateTfIdf(); // Return documents sorted by TF-IDF\n\n\n    return documents.sort(function (documentA, documentB) {\n      return calculateTfIdf(tokens, documentB, corpus) - calculateTfIdf(tokens, documentA, corpus);\n    });\n  };\n\n  _proto._createCalculateIdf = function _createCalculateIdf() {\n    var tokenMap = this._tokenMap;\n    var tokenToIdfCache = this._tokenToIdfCache;\n    return function calculateIdf(token, documents) {\n      if (!tokenToIdfCache[token]) {\n        var numDocumentsWithToken = typeof tokenMap[token] !== 'undefined' ? tokenMap[token].$numDocumentOccurrences : 0;\n        tokenToIdfCache[token] = 1 + Math.log(documents.length / (1 + numDocumentsWithToken));\n      }\n\n      return tokenToIdfCache[token];\n    };\n  };\n\n  _proto._createCalculateTfIdf = function _createCalculateTfIdf() {\n    var tokenMap = this._tokenMap;\n    var uidFieldName = this._uidFieldName;\n\n    var calculateIdf = this._createCalculateIdf();\n\n    return function calculateTfIdf(tokens, document, documents) {\n      var score = 0;\n\n      for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {\n        var token = tokens[i];\n        var inverseDocumentFrequency = calculateIdf(token, documents);\n\n        if (inverseDocumentFrequency === Infinity) {\n          inverseDocumentFrequency = 0;\n        }\n\n        var uid;\n\n        if (uidFieldName instanceof Array) {\n          uid = document && getNestedFieldValue(document, uidFieldName);\n        } else {\n          uid = document && document[uidFieldName];\n        }\n\n        var termFrequency = typeof tokenMap[token] !== 'undefined' && typeof tokenMap[token].$uidMap[uid] !== 'undefined' ? tokenMap[token].$uidMap[uid].$numTokenOccurrences : 0;\n        score += termFrequency * inverseDocumentFrequency;\n      }\n\n      return score;\n    };\n  };\n\n  return TfIdfSearchIndex;\n}();\n/**\n * Search index capable of returning results matching a set of tokens but without any meaningful rank or order.\n */\n\n\nvar UnorderedSearchIndex = /*#__PURE__*/function () {\n  function UnorderedSearchIndex() {\n    this._tokenToUidToDocumentMap = {};\n  }\n  /**\n   * @inheritDocs\n   */\n\n\n  var _proto = UnorderedSearchIndex.prototype;\n\n  _proto.indexDocument = function indexDocument(token, uid, doc) {\n    if (typeof this._tokenToUidToDocumentMap[token] !== 'object') {\n      this._tokenToUidToDocumentMap[token] = {};\n    }\n\n    this._tokenToUidToDocumentMap[token][uid] = doc;\n  }\n  /**\n   * @inheritDocs\n   */\n  ;\n\n  _proto.search = function search(tokens, corpus) {\n    var intersectingDocumentMap = {};\n    var tokenToUidToDocumentMap = this._tokenToUidToDocumentMap;\n\n    for (var i = 0, numTokens = tokens.length; i < numTokens; i++) {\n      var token = tokens[i];\n      var documentMap = tokenToUidToDocumentMap[token]; // Short circuit if no matches were found for any given token.\n\n      if (!documentMap) {\n        return [];\n      }\n\n      if (i === 0) {\n        var keys = Object.keys(documentMap);\n\n        for (var j = 0, numKeys = keys.length; j < numKeys; j++) {\n          var uid = keys[j];\n          intersectingDocumentMap[uid] = documentMap[uid];\n        }\n      } else {\n        var keys = Object.keys(intersectingDocumentMap);\n\n        for (var j = 0, numKeys = keys.length; j < numKeys; j++) {\n          var uid = keys[j];\n\n          if (typeof documentMap[uid] !== 'object') {\n            delete intersectingDocumentMap[uid];\n          }\n        }\n      }\n    }\n\n    var keys = Object.keys(intersectingDocumentMap);\n    var documents = [];\n\n    for (var i = 0, numKeys = keys.length; i < numKeys; i++) {\n      var uid = keys[i];\n      documents.push(intersectingDocumentMap[uid]);\n    }\n\n    return documents;\n  };\n\n  return UnorderedSearchIndex;\n}();\n\nvar REGEX = /[^a-zа-яё0-9\\-']+/i;\n/**\n * Simple tokenizer that splits strings on whitespace characters and returns an array of all non-empty substrings.\n */\n\nvar SimpleTokenizer = /*#__PURE__*/function () {\n  function SimpleTokenizer() {}\n\n  var _proto = SimpleTokenizer.prototype;\n  /**\n   * @inheritDocs\n   */\n\n  _proto.tokenize = function tokenize(text) {\n    return text.split(REGEX).filter(function (text) {\n      return text;\n    } // Filter empty tokens\n    );\n  };\n\n  return SimpleTokenizer;\n}();\n/**\n * Stemming is the process of reducing search tokens to their root (or stem) so that searches for different forms of a\n * word will match. For example \"search\", \"searching\" and \"searched\" are all reduced to the stem \"search\".\n *\n * <p>This stemming tokenizer converts tokens (words) to their stem forms before returning them. It requires an\n * external stemming function to be provided; for this purpose I recommend the NPM 'porter-stemmer' library.\n *\n * <p>For more information see http : //tartarus.org/~martin/PorterStemmer/\n */\n\n\nvar StemmingTokenizer = /*#__PURE__*/function () {\n  /**\n   * Constructor.\n   *\n   * @param stemmingFunction Function capable of accepting a word and returning its stem.\n   * @param decoratedIndexStrategy Index strategy to be run after all stop words have been removed.\n   */\n  function StemmingTokenizer(stemmingFunction, decoratedTokenizer) {\n    this._stemmingFunction = stemmingFunction;\n    this._tokenizer = decoratedTokenizer;\n  }\n  /**\n   * @inheritDocs\n   */\n\n\n  var _proto = StemmingTokenizer.prototype;\n\n  _proto.tokenize = function tokenize(text) {\n    return this._tokenizer.tokenize(text).map(this._stemmingFunction);\n  };\n\n  return StemmingTokenizer;\n}();\n/**\n * Stop words list copied from Lunr JS.\n */\n\n\nvar StopWordsMap = {\n  a: true,\n  able: true,\n  about: true,\n  across: true,\n  after: true,\n  all: true,\n  almost: true,\n  also: true,\n  am: true,\n  among: true,\n  an: true,\n  and: true,\n  any: true,\n  are: true,\n  as: true,\n  at: true,\n  be: true,\n  because: true,\n  been: true,\n  but: true,\n  by: true,\n  can: true,\n  cannot: true,\n  could: true,\n  dear: true,\n  did: true,\n  'do': true,\n  does: true,\n  either: true,\n  'else': true,\n  ever: true,\n  every: true,\n  'for': true,\n  from: true,\n  'get': true,\n  got: true,\n  had: true,\n  has: true,\n  have: true,\n  he: true,\n  her: true,\n  hers: true,\n  him: true,\n  his: true,\n  how: true,\n  however: true,\n  i: true,\n  'if': true,\n  'in': true,\n  into: true,\n  is: true,\n  it: true,\n  its: true,\n  just: true,\n  least: true,\n  \"let\": true,\n  like: true,\n  likely: true,\n  may: true,\n  me: true,\n  might: true,\n  most: true,\n  must: true,\n  my: true,\n  neither: true,\n  no: true,\n  nor: true,\n  not: true,\n  of: true,\n  off: true,\n  often: true,\n  on: true,\n  only: true,\n  or: true,\n  other: true,\n  our: true,\n  own: true,\n  rather: true,\n  said: true,\n  say: true,\n  says: true,\n  she: true,\n  should: true,\n  since: true,\n  so: true,\n  some: true,\n  than: true,\n  that: true,\n  the: true,\n  their: true,\n  them: true,\n  then: true,\n  there: true,\n  these: true,\n  they: true,\n  'this': true,\n  tis: true,\n  to: true,\n  too: true,\n  twas: true,\n  us: true,\n  wants: true,\n  was: true,\n  we: true,\n  were: true,\n  what: true,\n  when: true,\n  where: true,\n  which: true,\n  'while': true,\n  who: true,\n  whom: true,\n  why: true,\n  will: true,\n  'with': true,\n  would: true,\n  yet: true,\n  you: true,\n  your: true\n}; // Prevent false positives for inherited properties\n\nStopWordsMap.constructor = false;\nStopWordsMap.hasOwnProperty = false;\nStopWordsMap.isPrototypeOf = false;\nStopWordsMap.propertyIsEnumerable = false;\nStopWordsMap.toLocaleString = false;\nStopWordsMap.toString = false;\nStopWordsMap.valueOf = false;\n/**\n * Stop words are very common (e.g. \"a\", \"and\", \"the\") and are often not semantically meaningful in the context of a\n * search. This tokenizer removes stop words from a set of tokens before passing the remaining tokens along for\n * indexing or searching purposes.\n */\n\nvar StopWordsTokenizer = /*#__PURE__*/function () {\n  /**\n   * Constructor.\n   *\n   * @param decoratedIndexStrategy Index strategy to be run after all stop words have been removed.\n   */\n  function StopWordsTokenizer(decoratedTokenizer) {\n    this._tokenizer = decoratedTokenizer;\n  }\n  /**\n   * @inheritDocs\n   */\n\n\n  var _proto = StopWordsTokenizer.prototype;\n\n  _proto.tokenize = function tokenize(text) {\n    return this._tokenizer.tokenize(text).filter(function (token) {\n      return !StopWordsMap[token];\n    });\n  };\n\n  return StopWordsTokenizer;\n}();\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n/**\n * Simple client-side searching within a set of documents.\n *\n * <p>Documents can be searched by any number of fields. Indexing and search strategies are highly customizable.\n */\n\n\nvar Search = /*#__PURE__*/function () {\n  /**\n   * Array containing either a property name or a path (list of property names) to a nested value\n   */\n\n  /**\n   * Constructor.\n   * @param uidFieldName Field containing values that uniquely identify search documents; this field's values are used\n   *                     to ensure that a search result set does not contain duplicate objects.\n   */\n  function Search(uidFieldName) {\n    if (!uidFieldName) {\n      throw Error('js-search requires a uid field name constructor parameter');\n    }\n\n    this._uidFieldName = uidFieldName; // Set default/recommended strategies\n\n    this._indexStrategy = new PrefixIndexStrategy();\n    this._searchIndex = new TfIdfSearchIndex(uidFieldName);\n    this._sanitizer = new LowerCaseSanitizer();\n    this._tokenizer = new SimpleTokenizer();\n    this._documents = [];\n    this._searchableFields = [];\n  }\n  /**\n   * Override the default index strategy.\n   * @param value Custom index strategy\n   * @throws Error if documents have already been indexed by this search instance\n   */\n\n\n  var _proto = Search.prototype;\n  /**\n   * Add a searchable document to the index. Document will automatically be indexed for search.\n   * @param document\n   */\n\n  _proto.addDocument = function addDocument(document) {\n    this.addDocuments([document]);\n  }\n  /**\n   * Adds searchable documents to the index. Documents will automatically be indexed for search.\n   * @param document\n   */\n  ;\n\n  _proto.addDocuments = function addDocuments(documents) {\n    this._documents = this._documents.concat(documents);\n    this.indexDocuments_(documents, this._searchableFields);\n  }\n  /**\n   * Add a new searchable field to the index. Existing documents will automatically be indexed using this new field.\n   *\n   * @param field Searchable field or field path. Pass a string to index a top-level field and an array of strings for nested fields.\n   */\n  ;\n\n  _proto.addIndex = function addIndex(field) {\n    this._searchableFields.push(field);\n\n    this.indexDocuments_(this._documents, [field]);\n  }\n  /**\n   * Search all documents for ones matching the specified query text.\n   * @param query\n   * @returns {Array<Object>}\n   */\n  ;\n\n  _proto.search = function search(query) {\n    var tokens = this._tokenizer.tokenize(this._sanitizer.sanitize(query));\n\n    return this._searchIndex.search(tokens, this._documents);\n  }\n  /**\n   * @param documents\n   * @param _searchableFields Array containing property names and paths (lists of property names) to nested values\n   * @private\n   */\n  ;\n\n  _proto.indexDocuments_ = function indexDocuments_(documents, _searchableFields) {\n    this._initialized = true;\n    var indexStrategy = this._indexStrategy;\n    var sanitizer = this._sanitizer;\n    var searchIndex = this._searchIndex;\n    var tokenizer = this._tokenizer;\n    var uidFieldName = this._uidFieldName;\n\n    for (var di = 0, numDocuments = documents.length; di < numDocuments; di++) {\n      var doc = documents[di];\n      var uid;\n\n      if (uidFieldName instanceof Array) {\n        uid = getNestedFieldValue(doc, uidFieldName);\n      } else {\n        uid = doc[uidFieldName];\n      }\n\n      for (var sfi = 0, numSearchableFields = _searchableFields.length; sfi < numSearchableFields; sfi++) {\n        var fieldValue;\n        var searchableField = _searchableFields[sfi];\n\n        if (searchableField instanceof Array) {\n          fieldValue = getNestedFieldValue(doc, searchableField);\n        } else {\n          fieldValue = doc[searchableField];\n        }\n\n        if (fieldValue != null && typeof fieldValue !== 'string' && fieldValue.toString) {\n          fieldValue = fieldValue.toString();\n        }\n\n        if (typeof fieldValue === 'string') {\n          var fieldTokens = tokenizer.tokenize(sanitizer.sanitize(fieldValue));\n\n          for (var fti = 0, numFieldValues = fieldTokens.length; fti < numFieldValues; fti++) {\n            var fieldToken = fieldTokens[fti];\n            var expandedTokens = indexStrategy.expandToken(fieldToken);\n\n            for (var eti = 0, nummExpandedTokens = expandedTokens.length; eti < nummExpandedTokens; eti++) {\n              var expandedToken = expandedTokens[eti];\n              searchIndex.indexDocument(expandedToken, uid, doc);\n            }\n          }\n        }\n      }\n    }\n  };\n\n  _createClass(Search, [{\n    key: \"indexStrategy\",\n    set: function set(value) {\n      if (this._initialized) {\n        throw Error('IIndexStrategy cannot be set after initialization');\n      }\n\n      this._indexStrategy = value;\n    },\n    get: function get() {\n      return this._indexStrategy;\n    }\n    /**\n     * Override the default text sanitizing strategy.\n     * @param value Custom text sanitizing strategy\n     * @throws Error if documents have already been indexed by this search instance\n     */\n\n  }, {\n    key: \"sanitizer\",\n    set: function set(value) {\n      if (this._initialized) {\n        throw Error('ISanitizer cannot be set after initialization');\n      }\n\n      this._sanitizer = value;\n    },\n    get: function get() {\n      return this._sanitizer;\n    }\n    /**\n     * Override the default search index strategy.\n     * @param value Custom search index strategy\n     * @throws Error if documents have already been indexed\n     */\n\n  }, {\n    key: \"searchIndex\",\n    set: function set(value) {\n      if (this._initialized) {\n        throw Error('ISearchIndex cannot be set after initialization');\n      }\n\n      this._searchIndex = value;\n    },\n    get: function get() {\n      return this._searchIndex;\n    }\n    /**\n     * Override the default text tokenizing strategy.\n     * @param value Custom text tokenizing strategy\n     * @throws Error if documents have already been indexed by this search instance\n     */\n\n  }, {\n    key: \"tokenizer\",\n    set: function set(value) {\n      if (this._initialized) {\n        throw Error('ITokenizer cannot be set after initialization');\n      }\n\n      this._tokenizer = value;\n    },\n    get: function get() {\n      return this._tokenizer;\n    }\n  }]);\n\n  return Search;\n}();\n/**\n * This utility highlights the occurrences of tokens within a string of text. It can be used to give visual indicators\n * of match criteria within searchable fields.\n *\n * <p>For performance purposes this highlighter only works with full-word or prefix token indexes.\n */\n\n\nvar TokenHighlighter = /*#__PURE__*/function () {\n  /**\n   * Constructor.\n   *\n   * @param opt_indexStrategy Index strategy used by Search\n   * @param opt_sanitizer Sanitizer used by Search\n   * @param opt_wrapperTagName Optional wrapper tag name; defaults to 'mark' (e.g. <mark>)\n   */\n  function TokenHighlighter(opt_indexStrategy, opt_sanitizer, opt_wrapperTagName) {\n    this._indexStrategy = opt_indexStrategy || new PrefixIndexStrategy();\n    this._sanitizer = opt_sanitizer || new LowerCaseSanitizer();\n    this._wrapperTagName = opt_wrapperTagName || 'mark';\n  }\n  /**\n   * Highlights token occurrences within a string by wrapping them with a DOM element.\n   *\n   * @param text e.g. \"john wayne\"\n   * @param tokens e.g. [\"wa\"]\n   * @returns {string} e.g. \"john <mark>wa</mark>yne\"\n   */\n\n\n  var _proto = TokenHighlighter.prototype;\n\n  _proto.highlight = function highlight(text, tokens) {\n    var tagsLength = this._wrapText('').length;\n\n    var tokenDictionary = Object.create(null); // Create a token map for easier lookup below.\n\n    for (var i = 0, numTokens = tokens.length; i < numTokens; i++) {\n      var token = this._sanitizer.sanitize(tokens[i]);\n\n      var expandedTokens = this._indexStrategy.expandToken(token);\n\n      for (var j = 0, numExpandedTokens = expandedTokens.length; j < numExpandedTokens; j++) {\n        var expandedToken = expandedTokens[j];\n\n        if (!tokenDictionary[expandedToken]) {\n          tokenDictionary[expandedToken] = [token];\n        } else {\n          tokenDictionary[expandedToken].push(token);\n        }\n      }\n    } // Track actualCurrentWord and sanitizedCurrentWord separately in case we encounter nested tags.\n\n\n    var actualCurrentWord = '';\n    var sanitizedCurrentWord = '';\n    var currentWordStartIndex = 0; // Note this assumes either prefix or full word matching.\n\n    for (var i = 0, textLength = text.length; i < textLength; i++) {\n      var character = text.charAt(i);\n\n      if (character === ' ') {\n        actualCurrentWord = '';\n        sanitizedCurrentWord = '';\n        currentWordStartIndex = i + 1;\n      } else {\n        actualCurrentWord += character;\n        sanitizedCurrentWord += this._sanitizer.sanitize(character);\n      }\n\n      if (tokenDictionary[sanitizedCurrentWord] && tokenDictionary[sanitizedCurrentWord].indexOf(sanitizedCurrentWord) >= 0) {\n        actualCurrentWord = this._wrapText(actualCurrentWord);\n        text = text.substring(0, currentWordStartIndex) + actualCurrentWord + text.substring(i + 1);\n        i += tagsLength;\n        textLength += tagsLength;\n      }\n    }\n\n    return text;\n  }\n  /**\n   * @param text to wrap\n   * @returns Text wrapped by wrapper tag (e.g. \"foo\" becomes \"<mark>foo</mark>\")\n   * @private\n   */\n  ;\n\n  _proto._wrapText = function _wrapText(text) {\n    var tagName = this._wrapperTagName;\n    return \"<\" + tagName + \">\" + text + \"</\" + tagName + \">\";\n  };\n\n  return TokenHighlighter;\n}();\n\nexport { AllSubstringsIndexStrategy, CaseSensitiveSanitizer, ExactWordIndexStrategy, LowerCaseSanitizer, PrefixIndexStrategy, Search, SimpleTokenizer, StemmingTokenizer, StopWordsMap, StopWordsTokenizer, TfIdfSearchIndex, TokenHighlighter, UnorderedSearchIndex };","export const MESSAGE_TYPE = {\n  INIT: 'INIT',\n  SEARCH: 'SEARCH',\n}\n\nexport const getInitSearchEngineAction = (data) => getAction(MESSAGE_TYPE.INIT, data)\nexport const getSearchAction = (keyword) => getAction(MESSAGE_TYPE.SEARCH, keyword)\n\nfunction getAction(type, payload) {\n  return { type, payload }\n}\n","// In work.js, the import should be absolute path, not relative path\nimport { initSearch } from '@/utils/js-search'\nimport { MESSAGE_TYPE } from '@/templates/client-search/search.worker.actions'\n\nlet searchEngine = null\n\nfunction initSearchEngine(data) {\n  searchEngine = initSearch('path', ['path', 'rawBody'], data)\n}\n\nself.addEventListener('message', e => {\n  switch (e.data.type) {\n    case MESSAGE_TYPE.INIT:\n      initSearchEngine(e.data.payload)\n      break\n\n    case MESSAGE_TYPE.SEARCH:\n      self.postMessage(searchEngine.search(e.data.payload))\n      break\n\n    default:\n      console.log('do nothing...')\n  }\n})\n","import { flatten } from 'lodash'\nimport * as JsSearch from 'js-search'\n\nexport function initSearch(uid, indexes, documents) {\n  const search = new JsSearch.Search(uid)\n\n  const originTokenize = search.tokenizer.tokenize\n\n  search.tokenizer.tokenize = function(text) {\n    return flatten(\n      flatten(\n        text.split('/')\n          .filter(Boolean)\n          .map(v => v.split(/\\s+/)),\n      ).map((segment) => {\n        const enReg = /^[a-zA-Z0-9$@$!%*?&#^-_. +]+$/\n\n        if (enReg.test(segment)) {\n          return originTokenize(segment)\n        }\n\n        return segment.replace(/[\\x00-\\x7F]/g, \"\").split('')\n      })\n    )\n  }\n\n  indexes.forEach(index => search.addIndex(index))\n\n  search.addDocuments(documents)\n\n  return search\n}\n","var arrayPush = require('./_arrayPush'),\n    isFlattenable = require('./_isFlattenable');\n\n/**\n * The base implementation of `_.flatten` with support for restricting flattening.\n *\n * @private\n * @param {Array} array The array to flatten.\n * @param {number} depth The maximum recursion depth.\n * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.\n * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.\n * @param {Array} [result=[]] The initial result value.\n * @returns {Array} Returns the new flattened array.\n */\nfunction baseFlatten(array, depth, predicate, isStrict, result) {\n  var index = -1,\n      length = array.length;\n\n  predicate || (predicate = isFlattenable);\n  result || (result = []);\n\n  while (++index < length) {\n    var value = array[index];\n    if (depth > 0 && predicate(value)) {\n      if (depth > 1) {\n        // Recursively flatten arrays (susceptible to call stack limits).\n        baseFlatten(value, depth - 1, predicate, isStrict, result);\n      } else {\n        arrayPush(result, value);\n      }\n    } else if (!isStrict) {\n      result[result.length] = value;\n    }\n  }\n  return result;\n}\n\nmodule.exports = baseFlatten;\n","/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(document.body.children);\n * // => false\n *\n * _.isArray('abc');\n * // => false\n *\n * _.isArray(_.noop);\n * // => false\n */\nvar isArray = Array.isArray;\n\nmodule.exports = isArray;\n","var root = require('./_root');\n\n/** Built-in value references. */\nvar Symbol = root.Symbol;\n\nmodule.exports = Symbol;\n","var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n"],"sourceRoot":""}